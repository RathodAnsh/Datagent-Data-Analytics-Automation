"""
Interactive R Dashboard - Fixed Rendering
=========================================
Solves the "Blank Dashboard" issue by inline-embedding 
all external R/Plotly JavaScript dependencies.
"""

import streamlit as st
import streamlit.components.v1 as components
from pathlib import Path
import pandas as pd
import json
import os
import shutil
import re
import subprocess
import glob
from dotenv import load_dotenv

load_dotenv()

st.set_page_config(page_title="R Interactive Dashboard", layout="wide", page_icon="üìä")

# ==================== SETUP & PATHS ====================
TEMP_CHARTS_DIR = Path("temp_charts")
TEMP_DATA_DIR = Path("temp_data")
DATA_PATH = TEMP_DATA_DIR / "source.csv"
FILTERED_DATA_PATH = TEMP_DATA_DIR / "filtered_dashboard.csv"
CONFIG_PATH = TEMP_CHARTS_DIR / "kpi_config.json"
DASHBOARD_HTML = TEMP_CHARTS_DIR / "interactive_dashboard.html"

# Ensure directories exist
TEMP_DATA_DIR.mkdir(parents=True, exist_ok=True)
TEMP_CHARTS_DIR.mkdir(parents=True, exist_ok=True)

# ==================== CRITICAL FIX: DEPENDENCY INLINER ====================
def inline_html_dependencies(html_path):
    """
    Fixes blank dashboards by reading external JS/CSS files (generated by R)
    and embedding them directly into the HTML file.
    """
    if not html_path.exists():
        return False
    
    try:
        # Read the original HTML generated by R
        with open(html_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        parent_dir = html_path.parent
        
        # Regex to find <script src="..."> and <link href="...">
        # R usually outputs relative paths like "lib/jquery-3.6.0/jquery.min.js"
        script_pattern = re.compile(r'<script src="([^"]+)"></script>')
        link_pattern = re.compile(r'<link href="([^"]+)" rel="stylesheet" />')
        
        def replace_script(match):
            src = match.group(1)
            # Ignore web URLs (CDN), only process local files
            if src.startswith("http") or src.startswith("//"): return match.group(0)
            
            local_path = parent_dir / src
            if local_path.exists():
                try:
                    with open(local_path, 'r', encoding='utf-8') as jsf:
                        # Wrap JS content in <script> tags
                        return f'<script>\n{jsf.read()}\n</script>'
                except: pass
            return match.group(0)
            
        def replace_style(match):
            href = match.group(1)
            if href.startswith("http") or href.startswith("//"): return match.group(0)
            
            local_path = parent_dir / href
            if local_path.exists():
                try:
                    with open(local_path, 'r', encoding='utf-8') as cssf:
                        # Wrap CSS content in <style> tags
                        return f'<style>\n{cssf.read()}\n</style>'
                except: pass
            return match.group(0)
            
        # Perform replacements
        content = script_pattern.sub(replace_script, content)
        content = link_pattern.sub(replace_style, content)
        
        # Overwrite the HTML file with the fixed, self-contained version
        with open(html_path, 'w', encoding='utf-8') as f:
            f.write(content)
            
        return True
    except Exception as e:
        # print(f"Inline Error: {e}") 
        return False

# ==================== HELPER FUNCTIONS ====================

def load_kpi_config():
    if CONFIG_PATH.exists():
        try:
            with open(CONFIG_PATH, 'r') as f:
                return json.load(f)
        except:
            return None
    return None

def load_data():
    if st.session_state.get("dataframe") is not None:
        return st.session_state.dataframe
    if DATA_PATH.exists():
        try: return pd.read_csv(DATA_PATH, encoding='utf-8')
        except: return pd.read_csv(DATA_PATH, encoding='latin1')
    return None

def calculate_kpi_value(df, formula, agg_type):
    """Calculates KPI values from formulas."""
    try:
        series = None
        try:
            series = df.eval(formula)
        except:
            col_map = {c.lower(): c for c in df.columns}
            actual_col = col_map.get(str(formula).lower())
            if actual_col: series = df[actual_col]
        
        if series is None: return 0

        agg_type = agg_type.lower()
        if agg_type in ["count_distinct", "nunique", "distinct"]: return series.nunique()
        elif agg_type == "count": return len(series)
        
        series_numeric = pd.to_numeric(series, errors='coerce').fillna(0)
        if agg_type == "mean": return series_numeric.mean()
        else: return series_numeric.sum()
    except: return 0

def run_filtered_r_analysis(filtered_csv_path):
    """Re-runs R code on filtered data and FIXES the HTML output."""
    if "last_r_code" not in st.session_state or not st.session_state.last_r_code:
        return False
        
    r_code = st.session_state.last_r_code
    safe_path = str(filtered_csv_path).replace("\\", "/")
    
    final_code = re.sub(
        r"read\.csv\s*\(\s*['\"].*?['\"]", 
        f"read.csv('{safe_path}'", 
        r_code, count=1, flags=re.IGNORECASE
    )
    
    r_file_path = "temp_analysis_filtered.R"
    with open(r_file_path, "w", encoding="utf-8") as f: f.write(final_code)
    
    r_exec = shutil.which("Rscript")
    if not r_exec and os.name == 'nt':
        common_paths = sorted(glob.glob("C:/Program Files/R/R-*/bin/Rscript.exe"), reverse=True)
        if common_paths: r_exec = common_paths[0]
    
    if r_exec:
        subprocess.run([r_exec, r_file_path], capture_output=True, check=False)
        # CRITICAL: Inline dependencies immediately after R generates the file
        inline_html_dependencies(DASHBOARD_HTML)
        return True
    return False

# ==================== MAIN DASHBOARD LOGIC ====================

st.title("üìä Interactive Analytics Dashboard")

df = load_data()
kpi_config = load_kpi_config()

# Fix the HTML on initial load if it exists but hasn't been inlined yet
if DASHBOARD_HTML.exists():
    inline_html_dependencies(DASHBOARD_HTML)

dashboard_ready = DASHBOARD_HTML.exists()

if df is not None and dashboard_ready and kpi_config:

    # --- 1. SLICERS ---
    st.sidebar.header("üîç Filters")
    df_filtered = df.copy()
    active_filters = {}
    
    slicers = kpi_config.get("slicers", [])
    if isinstance(slicers, str): slicers = [slicers]
    
    for col_raw in slicers:
        col_map = {c.lower(): c for c in df.columns}
        col = col_map.get(str(col_raw).lower())
        
        if col:
            options = sorted(df[col].dropna().astype(str).unique())
            selected = st.sidebar.multiselect(f"{col.replace('_', ' ').title()}", options)
            if selected:
                active_filters[col] = selected
                df_filtered = df_filtered[df_filtered[col].astype(str).isin(selected)]

    # --- 2. KPIS ---
    st.markdown("### üìà Key Performance Indicators")
    kpis = kpi_config.get("kpis", [])
    if kpis:
        cols = st.columns(min(len(kpis), 4))
        for idx, kpi in enumerate(kpis):
            if idx >= 4: break
            label = kpi.get("label", "Metric")
            formula = kpi.get("formula")
            agg = kpi.get("agg", "sum")
            fmt = kpi.get("fmt", "num")
            
            val = calculate_kpi_value(df_filtered, formula, agg)
            
            if isinstance(val, (int, float)):
                if fmt == "$" or "revenue" in label.lower() or "price" in label.lower():
                    disp = f"${val:,.0f}"
                else:
                    disp = f"{val:,.0f}" if val % 1 == 0 else f"{val:,.2f}"
            else:
                disp = str(val)
            cols[idx].metric(label, disp)
    else:
        st.info("No KPIs configured.")

    # --- 3. VISUALS ---
    st.markdown("---")
    st.subheader("üìâ Interactive Analysis")
    
    current_filter_hash = str(active_filters)
    if "last_filter_hash" not in st.session_state:
        st.session_state.last_filter_hash = ""
        
    if current_filter_hash != st.session_state.last_filter_hash:
        with st.spinner("üîÑ Updating Visuals..."):
            df_filtered.to_csv(FILTERED_DATA_PATH, index=False)
            run_filtered_r_analysis(FILTERED_DATA_PATH)
            st.session_state.last_filter_hash = current_filter_hash

    try:
        # Read the (now fixed) HTML file
        with open(DASHBOARD_HTML, 'r', encoding='utf-8') as f:
            html_content = f.read()
        st.components.v1.html(html_content, height=800, scrolling=True)
    except Exception as e:
        st.error(f"Error rendering visualization: {e}")

else:
    st.warning("‚ö†Ô∏è Dashboard Not Ready")
    st.info("Please go to the **App** page, upload data, and ask a question first.")
    if st.button("‚¨ÖÔ∏è Go to App"):
        try: st.switch_page("app.py")
        except: pass

# Footer
st.markdown("---")
st.markdown("<div style='text-align: center; color: gray;'>AI Data Analyst Agent | R Edition</div>", unsafe_allow_html=True)